---
title: "Frist draft"
format: html
---

```{r}
#' Compute Detailed Analysis on Skeletal Part Abundance
#'
#' This function performs a comprehensive analysis on skeletal part abundance in archaeological sites.
#' It calculates various metrics such as the number of individuals, abundance, mean abundance,
#' mean part abundance, and other related statistics, providing deep insights into the origin and
#' characteristics of the bone assemblages. It's designed to aid in identifying patterns or anomalies
#' in skeletal part representation that can offer insights into hominin disposal practices or
#' post-depositional processes affecting these assemblages.
#'
#' @param MNE A numeric vector representing the Minimum Number of Elements (MNE) for each skeletal part.
#'            This is the primary input for the analysis.
#' @param ... Optional additional parameters that can be used to refine the analysis. 
#'            These could include specific filters or criteria based on the research focus.
#'
#' @return A list containing various calculated metrics: Number of Individuals, Abundance,
#'         Mean Abundance (MA), Mean Part Abundance (MPA), Minimum Number of Individuals (MNI),
#'         Minimum Animal Units (MAU), Minimal Number of Anatomic Units (MNAU), 
#'         Percentages of MAU and MNAU, Relative MNAU (ReMNAU), and Accumulative ReMNAU (AcReMNAU).
#'
#' @import dplyr
#' @importFrom tidyr gather
#' @importFrom stats setNames
#' @export
#'
#' @examples
#' \dontrun{
#'   MNE_vector <- c(/* MNE values for each skeletal part */)
#'   analysis_results <- analysis(MNE_vector)
#'   print(analysis_results)
#' }
analysis <- function(MNE, skeleton) {
    
    # Convert MNE to a data frame
    MNE <- as.data.frame(MNE)
    
    #MNI <- round(MNI/Skelton)
    if(length(MNE) != nrow(skeleton)) {
       stop("Length of MNE vector must match the number of skeletal elements")
     }
    MNI <- ceiling(MNE / skeleton$One_Skeleton)
    
    # Compute the number of Individuals (max(MNI))
    individuals <- max(MNI)
    
    # Compute max(MNI)
    MNI_animals <- MNE / skeleton$One_Skeleton
    animals <- max(MNI_animals)
    
    # Compute Abundance for each part
    abundance <- MNE / skeleton$One_Skeleton # expected_elements derived from Distinct Skeletal Parts

    # Compute Mean Abundance (MA) and Mean Part Abundance (MPA)
    ma <- mean(abundance)
    mpa <- sum(abundance) / length(distinct_skeletal_parts)

    # Additional metrics: MNI, MAU, MNAU, %MAU, %MNAU, ReMNAU, AcReMNAU
    # Calculations for each
    
    #
    MAU <- MNE / skeleton$One_Skeleton
      
    #  
    MNAU <- MNE / skeleton$One_Skeleton
      
    #  
    PMAU <- MAU/animals
    
    #  
    PMNAU <- MNAU/individuals
    
    #
    ReMNAU <- MNAU/sum(MNAU)
    
    #
    AcReMNAU = []
    AcReMNAU.append(MNAU[1])  
    for i in length(skeleton$One_Skeleton) -1
      AcReMNAU.append(AcReMNAU[i-1] + MNAu[i])
    
      
    # Return a list of all calculated metrics
    return(list(MNE=MNE, MNI = MNI , MAU = MAU, MNAU = MNAU, PercentMAU = PMAU, PercentMNAU = PMNAU, ReMNAU = ReMNAU, AcReMNAU = AcReMNAU, ma = ma, mpa= map ))
}


```

```{r}
MNE = c(6,6,4,5,3,2,22,35,57,15,3,4,5,10,104,8,9,10,12,10,20,30,128, 10, 2, 8,  6 , 12, 24,  30, 158, 188)
```

```{r}
analysis <- function(MNE, skeleton, individuals = NULL) {
    
    if(length(MNE) != nrow(skeleton)) {
        stop("Length of MNE vector must match the number of skeletal elements")
    }

    # Convert MNE to a data frame if it's not already
    if(!is.data.frame(MNE)) {
        MNE <- as.data.frame(MNE)
    }
    
    Elements <- skeleton$Elements
    
    # Calculate MNI and Individuals if not provided
    if(is.null(individuals)) {
        MNI <- ceiling(MNE$MNE / skeleton$One_Skeleton)
        individuals <- max(MNI)
    } 
    
    # Compute Abundance for each part
    abundance <- MNE$MNE / (skeleton$One_Skeleton *individuals)

    # Compute Mean Abundance (MA)
    ma <- sum(MNE$MNE, na.rm = TRUE) / (sum(skeleton$One_Skeleton, na.rm = TRUE) * individuals)

    # Compute Mean Part Abundance (MPA)
    mpa <- sum(abundance, na.rm = TRUE) / length(abundance)

    # Additional metrics calculations
    MAU <- abundance
    MNAU <- abundance
    PMAU <- MAU / max(MNE$MNE / skeleton$One_Skeleton )
    PMNAU <- MNAU / individuals
    ReMNAU <- MNAU / sum(MNAU, na.rm = TRUE)

    # Calculate Accumulative ReMNAU
    AcReMNAU <- cumsum(ReMNAU)
    
    # Return a list of all calculated metrics
    return(list(MNE = as.vector(MNE$MNE), Elements = Elements,abundance = max(MNE$MNE / skeleton$One_Skeleton ) ,MNI = individuals, MAU = MAU, MNAU = MNAU, PercentMAU = PMAU, 
                PercentMNAU = PMNAU, ReMNAU = ReMNAU, AcReMNAU = AcReMNAU, MeanAbundance = ma, MeanPartAbundance = mpa))
}


```

```{r}
SH_data = analysis(MNE,skeleton)
```

```{r}
SH_data
```

```{r}
MNE
```

```{r}
# Create the skeleton data
   skeleton <- data.frame(
         Elements = c("Cranium", "Mandible", "Maxillae", "Hyoid", "Atlas (C1)", "Axis (C2)",
                     "Cervical (C2-C7)", "Cervical total", "Thoracic", "Lumbar", "Sacrum", 
                     "Coccyx", "Sternum", "Clavicle", "Rib", "Scapula", "Humerus", "Radius", 
                     "Ulna", "Carpals", "Metacarpal", "Hand phalanx", "Hand (metacarpals + manual phalanges)", 
                     "Innominate (Os coxa)", "Femur", "Patella", "Tibia", "Fibula", 
                     "Tarsal", "Metatarsal", "Foot phalanx", "Foot (metatarsals + pedal phalanges)"),
        One_Skeleton = c(1, 1, 1, 1, 1, 1, 5, 7, 12, 5, 1, 1, 1, 2, 24, 2, 2, 2, 2, 16, 10, 28, 38, 2, 2, 2, 2, 2, 14, 10, 28, 38)
        )
    
save(skeleton, file = "data/skeleton.rda")
```

```{r}
skeleton$Elements
```

```{r}
# Define sites
sites <- c("Krapina", "Palomas", "Sunghir", "Carnivore", "Cannibale", "Baboon")

# Set seed for reproducibility
set.seed(0)

# Create a list to store site vectors
site_vectors <- list()

# Iterate through sites and create random 33-dimensional vectors for each
for (site in sites) {
  individuals <- sample(3:33, 1)  # Random number between 3 and 33
  site_vectors[[site]] <-  ceiling(individuals * skeleton$One_Skeleton * runif(nrow(skeleton)))
}

# Display site vectors
site_vectors

```

```{r}
#"Krapina", "Palomas", "Sunghir", "Carnivore", "Cannibale", "Baboon"
Krapina_analysis <- analysis(site_vectors$Krapin, skeleton)
Palomas_analysis <- analysis(site_vectors$Palomas, skeleton)
Sunghir_analysis <- analysis(site_vectors$Sunghir, skeleton)
Carnivore_analysis <- analysis(site_vectors$Carnivore, skeleton)
Cannibale_analysis <- analysis(site_vectors$Cannibale, skeleton)
Baboon_analysis <- analysis(site_vectors$Baboon, skeleton)
```

```{r}
Sunghir_analysis
```

```{r}
plot_abundance <- function(SH_df, value, comp_sites, site_vectors, elements) {
    # Convert SH_data list to a data frame for plotly
    #SH_df <- data.frame(Element = elements, Value = SH_data$value)
    #print(SH_df)
    # Create base plot for SH site
    p <- plotly::plot_ly(data = SH_df, x = ~Element, y = ~Value, 
                         type = 'scatter', mode = 'lines+markers', name = 'SH')
  
    # Add plots for comparison sites
    for (site in comp_sites) {
        if (!site %in% names(site_vectors)) {
            next
        }
        comp_df <- data.frame(Element = skeleton$Elements, Value = site_vectors[[site]][[value]])
        p <- p %>% plotly::add_trace(data = comp_df, x = ~Element, y = ~Value,
        mode = 'lines+markers', name = site)
        }

    # Customize layout
    p %>% plotly::layout(title = paste("Abundance Comparison:", value),
                     xaxis = list(title = "Skeletal Elements"),
                     yaxis = list(title = value))
    }

```

```{r}
plot_abundance(SH_df, MNAU, c("Baboon"), Baboon_analysis, skeleton$Elements )
```

```{r}
names(SH_data)
SH_df<- data.frame(Element = skeleton$Elements, MNAU = SH_data$MNAU)
```

```{r}
plot_mau_vs_mni <- function(SH_data) {
    plotly::plot_ly(SH_data, x = ~MAU, y = ~MNI, type = 'scatter', mode = 'markers',
                    marker = list(size = 10)) %>%
    plotly::layout(title = "MAU vs MNI for SH Site",
                   xaxis = list(title = "MAU"),
                   yaxis = list(title = "MNI"))
}

plot_mau_vs_mni(SH_df)
```

```{r}
data <- data.frame(row.names = SH_data$Elements, MNAU_SH= SH_data$MNAU, MNAU_Sun= Sunghir_analysis$MNAU)
acre_data <- data.frame(row.names = SH_data$Elements, AcReMNAU_SH= SH_data$AcReMNAU, AcReMNAU_Sun= Sunghir_analysis$AcReMNAU)
```

```{r}
library(plotly)
Elements <- data[0]
fig <- plot_ly(data, x = ~Elements, y = ~MNAU_SH ,name = "SH",type = 'scatter', mode = 'lines+markers')

fig <- fig %>% add_trace(y = ~MNAU_Sun, name= "sunghir", mode = 'lines+markers')

fig 

```

```{r}
fig <- plot_ly(acre_data, x = ~Elements, y = ~AcReMNAU_SH ,name = "SH",type = 'scatter', mode = 'lines+markers')

fig <- fig %>% add_trace(y = ~AcReMNAU_Sun, name= "sunghir", mode = 'lines+markers')



fig 

```

```{r}

fig <- plot_ly(acre_data, x = ~Elements, y = ~AcReMNAU_SH, name = "SH", type = 'scatter', mode = 'lines+markers')
fig <- fig %>% add_trace(x = ~Elements, y = ~AcReMNAU_Sun, name = "Sunghir", mode = 'lines+markers')

# Add identity line
# X-axis from 0 to 1
x_identity_line <- c(0, length(row.names(acre_data)))

# Y-axis from 0 to length of Elements
y_identity_line <- c(0, 1)

# Add the identity line to the plot
fig <- fig %>% add_trace(x = x_identity_line, y = y_identity_line, mode = 'lines', line = list(dash = 'dot'), name = "Identity Line")

fig 
```

```{r}
length(row.names(acre_data))
```

## next

```{r}

set.seed(42)
source("../INPUT/FUNCTIONS/preprocess.R")
library(dplyr)
library(rsample)
library(recipes)
library(randomForest)
library(corrplot)
library(tibble)
library(purrr)
library(reshape2)
library(ggplot2)
library(plotly)
library(scatterplot3d)
library(factoextra)
library(cluster)
library(tidyverse)
```

```{r}
data <- read.csv('../Input/DATA/Summary_Dataset_Used_Percentage_MAU.csv')
data_multi <- read.csv('../Input/DATA/Summary_Dataset_Multivar_Percentage_MAU.csv')
```

```{r}
data_multi
```

```{r}


```

```{r}
data_multi[8:28,]
```

```{r}
data = preprocess(data)
data_multi = preprocess(data_multi)
glimpse(data)
```

```{r}
Sima_de_los_Huesos <- data_multi[37,]
Sima_de_los_Huesos
```

```{r}
# Define the columns for which you want to count the labels
columns_to_count <- c("Type", "AccumulationType", "Individuals", "Cluster_Pnas")

# Function to count labels in each specified column
count_labels <- function(data, columns) {
  sapply(data[columns], function(column) table(column))
}

# Use the function to count labels
label_counts <- count_labels(data, columns_to_count)

# Print the counts
label_counts
```

```{r}
data_rf_sup <- data_multi %>% select(-c("AccumulationType"))
```

```{r}
data_rf_sup
```

```{r}
for (i in seq(4)){
  fig <- fig %>%
    add_segments(x = 0, xend = loadings[i, 1], y = 0, yend = loadings[i, 2], line = list(color = 'yellow'),inherit = FALSE, showlegend = FALSE) %>%
    add_annotations(x=loadings[i, 1], y=loadings[i, 2], ax = 0, ay = 0,text = features[i], xanchor = 'center', yanchor= 'bottom')
}
```

```{r}
library(plotly)
library(stats)
data(iris)
X <- subset(iris, select = -c(Species))
prin_comp <- prcomp(X, rank = 2)
components <- prin_comp[["x"]]
components <- data.frame(components)
components <- cbind(components, iris$Species)
components$PC2 <- -components$PC2
explained_variance <- summary(prin_comp)[["sdev"]]
explained_variance <- explained_variance[1:2]
comp <- prin_comp[["rotation"]]
comp[,'PC2'] <- - comp[,'PC2']
loadings <- comp
for (i in seq(explained_variance)){
  loadings[,i] <- comp[,i] * explained_variance[i]
}

features = c('sepal_length', 'sepal_width', 'petal_length', 'petal_width')

fig <- plot_ly(components, x = ~PC1, y = ~PC2, color = ~iris$Species, colors = c('#636EFA','#EF553B','#00CC96'), type = 'scatter', mode = 'markers') %>%
  layout(
    legend=list(title=list(text='color')),
    plot_bgcolor = "#e5ecf6",
    xaxis = list(
      title = "0"),
    yaxis = list(
      title = "1"))


fig
```

```{r}
data("iris")

X <- subset(iris, select = -c(Species))

prin_comp <- prcomp(X, rank. = 3)

components <- prin_comp[["x"]]
components <- data.frame(components)
components$PC2 <- -components$PC2
components$PC3 <- -components$PC3
components = cbind(components, iris$Species)

tot_explained_variance_ratio <- summary(prin_comp)[["importance"]]['Proportion of Variance',]
tot_explained_variance_ratio <- 100 * sum(tot_explained_variance_ratio)

tit = 'Total Explained Variance = 99.48'

fig <- plot_ly(components, x = ~PC1, y = ~PC2, z = ~PC3, color = ~iris$Species, colors = c('#636EFA','#EF553B','#00CC96') ) %>%
  add_markers(size = 12)


fig <- fig %>%
  layout(
    title = tit,
    scene = list(bgcolor = "#e5ecf6")
)
for (i in seq(4)){
  fig <- fig %>%
    add_segments(x = 0, xend = loadings[i, 1], y = 0, yend = loadings[i, 2], line = list(color = 'yellow'),inherit = FALSE, showlegend = FALSE) %>%
    add_annotations(x=loadings[i, 1], y=loadings[i, 2], ax = 0, ay = 0,text = features[i], xanchor = 'center', yanchor= 'bottom')
}

fig
```

```{r}
library(plotly)
library(stats)
library(MASS)

db = Boston

prin_comp <- prcomp(db, rank. = 4)

components <- prin_comp[["x"]]
components <- data.frame(components)
components <- cbind(components, db$medv)
components$PC2 <- -components$PC2
colnames(components)[5] = 'Median_Price'

tot_explained_variance_ratio <- summary(prin_comp)[["importance"]]['Proportion of Variance',]
tot_explained_variance_ratio <- 100 * sum(tot_explained_variance_ratio)

tit = 'Total Explained Variance = 99.56'

axis = list(showline=FALSE,
            zeroline=FALSE,
            gridcolor='#ffff',
            ticklen=4)

fig <- components %>%
  plot_ly() %>%
  add_trace(
    type = 'splom',
    dimensions = list(
      list(label='PC1', values=~PC1),
      list(label='PC2', values=~PC2),
      list(label='PC3', values=~PC3),
      list(label='PC4', values=~PC4)
    ),
    color=~Median_Price,
    marker = list(
      size = 7
    )
  ) %>% style(diagonal = list(visible = F)) %>%
  layout(
    title= tit,
    hovermode='closest',
    dragmode= 'select',
    plot_bgcolor='rgba(240,240,240, 0.95)',
    xaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),
    yaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),
    xaxis2=axis,
    xaxis3=axis,
    xaxis4=axis,
    yaxis2=axis,
    yaxis3=axis,
    yaxis4=axis
  )
options(warn=-1)
fig
```

```{r}
library(plotly)
library(stats)
data(iris)
X <- subset(iris, select = -c(Species))
prin_comp <- prcomp(X)
explained_variance_ratio <- summary(prin_comp)[["importance"]]['Proportion of Variance',]
explained_variance_ratio <- 100 * explained_variance_ratio
components <- prin_comp[["x"]]
components <- data.frame(components)
components <- cbind(components, iris$Species)
components$PC3 <- -components$PC3
components$PC2 <- -components$PC2

axis = list(showline=FALSE,
            zeroline=FALSE,
            gridcolor='#ffff',
            ticklen=4,
            titlefont=list(size=13))

fig <- components %>%
  plot_ly()  %>%
  add_trace(
    type = 'splom',
    dimensions = list(
      list(label=paste('PC 1 (',toString(round(explained_variance_ratio[1],1)),'%)',sep = ''), values=~PC1),
      list(label=paste('PC 2 (',toString(round(explained_variance_ratio[2],1)),'%)',sep = ''), values=~PC2),
      list(label=paste('PC 3 (',toString(round(explained_variance_ratio[3],1)),'%)',sep = ''), values=~PC3),
      list(label=paste('PC 4 (',toString(round(explained_variance_ratio[4],1)),'%)',sep = ''), values=~PC4)
    ),
    color = ~iris$Species, colors = c('#636EFA','#EF553B','#00CC96')
  ) %>%
  style(diagonal = list(visible = FALSE)) %>%
  layout(
    legend=list(title=list(text='color')),
    hovermode='closest',
    dragmode= 'select',
    plot_bgcolor='rgba(240,240,240, 0.95)',
    xaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),
    yaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),
    xaxis2=axis,
    xaxis3=axis,
    xaxis4=axis,
    yaxis2=axis,
    yaxis3=axis,
    yaxis4=axis
  )

fig
```

```{r}
library(ape)
library(stats) # for hclust and example data set

# create hclust object
#X <- subset(data_rf_sup, select = -c(Type))
hclust.tree<-hclust(dist(data_means))
plot(hclust.tree)

# convert into phylo object
phylo.tree <- as.phylo(hclust.tree)
phylo.tree
plot(phylo.tree)

# phylogenetic tree is ultrametric and binary 
is.ultrametric(phylo.tree)
is.binary.tree(phylo.tree)

# convert back into hclust object
converted.tree <- as.hclust(phylo.tree)
plot(converted.tree)
```

```{r}
library(ape)
library(stats) # for hclust and example data set

# create hclust object
#X <- subset(data_rf_sup, select = -c(Type))
hclust.tree<-hclust(dist(data_means_sm))
plot(hclust.tree)

# convert into phylo object
phylo.tree <- as.phylo(hclust.tree)
phylo.tree
plot(phylo.tree)

# phylogenetic tree is ultrametric and binary 
is.ultrametric(phylo.tree)
is.binary.tree(phylo.tree)

# convert back into hclust object
converted.tree <- as.hclust(phylo.tree)
plot(converted.tree)
```

```{r}
data <- data %>% select(-c("Type", "AccumulatioType", "Cluster_Pnas"))
#data <- subset(data, select = -c("Type", "AccumulatioType", "Cluster_Pnas"))
data
```

```{r}
colnames(data_rf_sup)
```

```{r}
subset(data_multi, select = -c(Type))
```

```{r}
tibble::column_to_rownames(data_rf_sup, var = "Type")
```

```{r}
data_rf_sup <- tibble::column_to_rownames(data_rf_sup, var = Type)
data_rf_sup
```

```{r}
# Load necessary library
library(tibble)
# Assuming data_rf_sup is your data frame or tibble
row.names(data_rf_sup) <- NULL

# Assuming data_rf_sup is your tibble
data_rf_sup <- as.data.frame(data_rf_sup) # Convert to a data frame

# Change the index by making 'Type' the row names
data_rf_sup <- tibble::column_to_rownames(data_rf_sup, var = "Type")

# If you need it back as a tibble
data_rf_sup <- as_tibble(data_rf_sup)

```

```{r}
# Load the dplyr library
library(dplyr)

# Assuming 'data' is your data frame and it has other columns like 'value1', 'value2', etc.
# Group by 'Type' and then calculate the mean for each group
data_means_ac <- data %>%
  group_by(AccumulationType) %>%
  summarize(across(everything(), mean, na.rm = TRUE))

# 'data_means' now contains the mean of each column for each 'Type'

```

```{r}
data_means_ac 
```

```{r}
data_means$AccumulationType <- NULL
data_means <- tibble::column_to_rownames(data_means, var = "Type")

```

```{r}
data_means_ac$Type <- NULL
data_means_ac <- tibble::column_to_rownames(data_means_ac, var = "AccumulationType")

```

```{r}
# Load the dplyr library
library(dplyr)

# Extract the 'Sima_de_los_Huesos' row
Sima_de_los_Huesos <- data_multi[37,]

# Remove the 'Sima_de_los_Huesos' row from data
data_multi <- data_multi[-37,]

# Group by 'Type' and then calculate the mean for each group (excluding Sima_de_los_Huesos)
data_means_sm_ac <- data_multi %>%
  group_by(AccumulationType) %>%
  summarize(across(everything(), mean, na.rm = TRUE))


```

```{r}
data_means_sm_ac
```

```{r}
Sima_de_los_Huesos[,-c(1,2)]
```

```{r}
# Merge the 'Sima_de_los_Huesos' row back into the data_means
data_means_sm_ac <- bind_rows(Sima_de_los_Huesos[,-c(1,2)], data_means_sm_ac[,-c(2)])

# 'data_means' now contains the mean of each column for each 'Type', 
# including the 'Sima_de_los_Huesos' row
data_means_sm_ac
Sima_de_los_Huesos[,-c(1,2)]
```

```{r}
data_means_sm_ac$AccumulationType[2:5]
```

```{r}
row.names(data_means_sm_ac)[2:5] <- data_means_sm_ac$AccumulationType[2:5]
row.names(data_means_sm_ac)
```

```{r}
row.names(data_means_sm)[2:10] <- data_means_sm$Type[2:10]
row.names(data_means_sm)
```

## data_means_SH

```{r}
data_means_sm_type <- data_means_sm
data_means_sm_type
```

```{r}
library(ape)
library(stats) # for hclust and example data set

# create hclust object
#X <- subset(data_rf_sup, select = -c(Type))
hclust.tree<-hclust(dist(data_means_sm))
plot(hclust.tree)

# convert into phylo object
phylo.tree <- as.phylo(hclust.tree)
phylo.tree
plot(phylo.tree)

# phylogenetic tree is ultrametric and binary 
is.ultrametric(phylo.tree)
is.binary.tree(phylo.tree)

# convert back into hclust object
converted.tree <- as.hclust(phylo.tree)
plot(converted.tree)
```

```{r}
library(ape)
library(stats) # for hclust and example data set

# create hclust object
#X <- subset(data_rf_sup, select = -c(Type))
hclust.tree<-hclust(dist(data_means_sm_ac))
plot(hclust.tree)

# convert into phylo object
phylo.tree <- as.phylo(hclust.tree)
phylo.tree
plot(phylo.tree)

# phylogenetic tree is ultrametric and binary 
is.ultrametric(phylo.tree)
is.binary.tree(phylo.tree)

# convert back into hclust object
converted.tree <- as.hclust(phylo.tree)
plot(converted.tree)
```

```{r}
data_means_sm_ac
```

```{r}
data_means_sm_type <- data_means_sm_type[,-24]
```

```{r}
data_multi
```

```{r}
prin_comp <- prcomp(data_multi[,-c(1,2)], rank. = 3)

components <- prin_comp[["x"]]
components <- data.frame(components)
components$PC2 <- -components$PC2
components$PC3 <- -components$PC3
components = cbind(components, data_multi$Type)

tot_explained_variance_ratio <- summary(prin_comp)[["importance"]]['Proportion of Variance',]
tot_explained_variance_ratio <- 100 * sum(tot_explained_variance_ratio)

tit = 'Total Explained Variance ='

fig <- plot_ly(components, x = ~PC1, y = ~PC2, z = ~PC3, color = ~data_multi$Type, colors = c('#636EFA','#EF553B','#00CC96') ) %>%
  add_markers(size = 12)


fig <- fig %>%
  layout(
    title = tit,
    scene = list(bgcolor = "#e5ecf6")
)


fig
```

```{r}
prin_comp <- prcomp(data_means_sm_type, rank. = 3)

components <- prin_comp[["x"]]
components <- data.frame(components)
components$PC2 <- -components$PC2
components$PC3 <- -components$PC3
components = cbind(components, row.names(data_means_sm_type))

tot_explained_variance_ratio <- summary(prin_comp)[["importance"]]['Proportion of Variance',]
tot_explained_variance_ratio <- 100 * sum(tot_explained_variance_ratio)

tit = 'Total Explained Variance ='

fig <- plot_ly(components, x = ~PC1, y = ~PC2, z = ~PC3, color = ~row.names(data_means_sm_type), colors = c('#636EFA','#EF553B','#00CC96') ) %>%
  add_markers(size = 12)


fig <- fig %>%
  layout(
    title = tit,
    scene = list(bgcolor = "#e5ecf6")
)


fig
```

```{r}
library(plotly)
library(stats)
library(MASS)

db = data_means_sm_type

prin_comp <- prcomp(db, rank. = 4)

components <- prin_comp[["x"]]
components <- data.frame(components)
components <- cbind(components, row.names(db))
components$PC2 <- -components$PC2
colnames(components)[5] = 'Type'

tot_explained_variance_ratio <- summary(prin_comp)[["importance"]]['Proportion of Variance',]
tot_explained_variance_ratio <- 100 * sum(tot_explained_variance_ratio)

tit = 'Total Explained Variance = '

axis = list(showline=FALSE,
            zeroline=FALSE,
            gridcolor='#ffff',
            ticklen=4)

fig <- components %>%
  plot_ly() %>%
  add_trace(
    type = 'splom',
    dimensions = list(
      list(label='PC1', values=~PC1),
      list(label='PC2', values=~PC2),
      list(label='PC3', values=~PC3),
      list(label='PC4', values=~PC4)
    ),
    color=~row.names(db),
    marker = list(
      size = 7
    )
  ) %>% style(diagonal = list(visible = F)) %>%
  layout(
    title= tit,
    hovermode='closest',
    dragmode= 'select',
    plot_bgcolor='rgba(240,240,240, 0.95)',
    xaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),
    yaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),
    xaxis2=axis,
    xaxis3=axis,
    xaxis4=axis,
    yaxis2=axis,
    yaxis3=axis,
    yaxis4=axis
  )
options(warn=-1)
fig
```

```{r}
library(plotly)
library(stats)
library(MASS)

db = data_transformed

prin_comp <- prcomp(db[,-c(1,2)], rank. = 4)

components <- prin_comp[["x"]]
components <- data.frame(components)
components <- cbind(components, db$Type)
components$PC2 <- -components$PC2
colnames(components)[5] = 'Type'

# Define a set of 8 colors
colors <- c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f")

# Assign colors based on 'Type'
components$Color <- colors[as.numeric(as.factor(components$Type)) %% length(colors) + 1]

tot_explained_variance_ratio <- summary(prin_comp)[["importance"]]['Proportion of Variance',]
tot_explained_variance_ratio <- 100 * sum(tot_explained_variance_ratio)

tit = 'Total Explained Variance = '

axis = list(showline=FALSE, zeroline=FALSE, gridcolor='#ffff', ticklen=4)

fig <- components %>%
  plot_ly() %>%
  add_trace(
    type = 'splom',
    dimensions = list(
      list(label='PC1', values=~PC1),
      list(label='PC2', values=~PC2),
      list(label='PC3', values=~PC3),
      list(label='PC4', values=~PC4)
    ),
    color = ~Color,  # Use the custom color column
    marker = list(size = 7)
  ) %>% 
  style(diagonal = list(visible = F)) %>%
  layout(
    title = tit,
    hovermode = 'closest',
    dragmode = 'select',
    plot_bgcolor = 'rgba(240,240,240, 0.95)',
    xaxis = list(domain = NULL, showline = F, zeroline = F, gridcolor = '#ffff', ticklen = 4),
    yaxis = list(domain = NULL, showline = F, zeroline = F, gridcolor = '#ffff', ticklen = 4),
    xaxis2 = axis,
    xaxis3 = axis,
    xaxis4 = axis,
    yaxis2 = axis,
    yaxis3 = axis,
    yaxis4 = axis
  )
options(warn = -1)
fig

```

```{r}
colnames(db)
```

```{r}
library(plotly)
library(stats)
X <- db
prin_comp <- prcomp(data_transformed[,-c(1,2)], rank = 2)
components <- prin_comp[["x"]]
components <- data.frame(components)
components <- cbind(components, row.names(db))
components$PC2 <- -components$PC2
explained_variance <- summary(prin_comp)[["sdev"]]
explained_variance <- explained_variance[1:2]
comp <- prin_comp[["rotation"]]
comp[,'PC2'] <- - comp[,'PC2']
loadings <- comp
for (i in seq(explained_variance)){
  loadings[,i] <- comp[,i] * explained_variance[i]
}

features = c("Thoracic","Lumbar","Sacrum" ,        "Radius"                   ,             "Ulna" ,                       "Sternum"  )

fig <- plot_ly(components, x = ~PC1, y = ~PC2, color = ~db$Type, colors = c('#636EFA','#EF553B','#00CC96'), type = 'scatter', mode = 'markers') %>%
  layout(
    legend=list(title=list(text='color')),
    plot_bgcolor = "#e5ecf6",
    xaxis = list(
      title = "0"),
    yaxis = list(
      title = "1"))
for (i in seq(6)){
  fig <- fig %>%
    add_segments(x = 0, xend = loadings[i, 1]*5, y = 0, yend = loadings[i, 2], line = list(color = 'black'),inherit = FALSE, showlegend = FALSE) %>%
    add_annotations(x=loadings[i, 1], y=loadings[i, 2]*5, ax = 0, ay = 0,text = features[i], xanchor = 'center', yanchor= 'bottom')
}

fig
```

```{r}
Sima_de_los_Huesos <- data_multi[37,]
#data_multi <- data_multi[-37,]
data_multi[-c(1:30),]
```

```{r}
# Store original row names of the datasets
data_row_names <- row.names(data_multi)
sh_row_names <- row.names(Sima_de_los_Huesos)

# Step 1: Create a recipe
recipe <- recipe(~ ., data = data_multi) %>%
  step_normalize(all_predictors(), -all_of(c("Type", "AccumulationType")))

# Step 2: Fit the recipe to the training set
fitted_recipe <- prep(recipe, training = data_multi)

# Step 3: Apply the transformation to both training and test sets
data_transformed <- bake(fitted_recipe, new_data = data_multi)
sh_transformed <- bake(fitted_recipe, new_data = Sima_de_los_Huesos)

# Reattach the row names
rownames(data_transformed) <- data_row_names
rownames(sh_transformed) <- sh_row_names

```

```{r}
sh_transformed
```

```{r}
data_transformed$Type[37] <- "Sima_de_los_Huesos"
```

```{r}
data_transformed$Type
```
